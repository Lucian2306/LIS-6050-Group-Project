# -*- coding: utf-8 -*-
"""
Group Project: Cryptocurrency

Created: April 2018
Authors: Amy Hoffman, Deb Dorsey, J. Lucian Rathbun, Ryan Reed
Course: LIS 6050 Introduction to Computer Programming 
University: Wayne State University 
Python version: 3.6x
"""
'''ANALYSIS MODULE'''

'''This is the analysis module for the cryptodesk program, functions included 
are summary, mean, median, minimum, maximum, and return all curriencies  
with values above/below/in a range for a given data point. User will be able to 
choose which currency/ies they want to examine and which data fields. 
These should be passed as arguments of the functions. Output will be nicely 
formatted strings that make it clear which currencies were chosen, and what the 
statistic refers to.'''

import statistics as stat
#won't need to use the API in the module itself later, just here for now
#for testing
import requests

response = requests.get('https://api.coinmarketcap.com/v1/ticker/?limit=0')

cmcData = response.json()

'''WORKS BUT OUTPUT NEEDS PRETTYING UP'''
def summary(datalist, currencylist):
    # create empty list of results
    cList = []
    #iterate currency input, remove spaces, make lowercase, and append to list
    for i in currencylist: 
        currency = i.lower().strip()
        cList.append(currency)
    # Iterate through datalist, lowercase and strip spaces, then check if each
    # item matches each item that was input.  Where there is a match, print
    # the entire dictionary nicely formatted. Pass if there is no match.
    for i in datalist:
        sName = i["name"].lower().strip()
        for c in cList:
            if c == sName:
                print(i)
            else:
                pass
                

''' WORKS BUT OUTPUT NEEDS PRETTYING UP'''
def average(datalist, currencylist, field):
    # create empty lists for data to be put into
    cList = []
    vList = []
    #iterate currency input, remove spaces, make lowercase, and append to list
    for i in currencylist:
        currency = i.lower().strip()
        cList.append(currency)
    # Iterate through datalist, lowercase and strip spaces, then check if each
    # the value for the given field matches each value from the cList. If yes,
    # add to vList.  If no, pass.
    for c in cList:
        for n in datalist:
            if c == n["name"].lower().strip():
                fValue = float(n[field])
                vList.append(fValue)
            else:
                pass
    # find and print the mean value for vList, nicely formatted
    aValue = stat.mean(vList)
    print("The average", field, "value is:", aValue)
    #need to make currencylist a string


'''WORKS BUT OUTPUT NEEDS PRETTYING'''   
def med(datalist, currencylist, field):
    # create empty lists for data to be put into
    cList = []
    vList = []
    #iterate currency input, remove spaces, make lowercase, and append to list
    for i in currencylist:
        currency = i.lower().strip()
        cList.append(currency)
    # Iterate through datalist, lowercase and strip spaces, then check if each
    # the value for the given field matches each value from the cList. If yes,
    # add to vList.  If no, pass.
    for n in datalist:    
        for c in cList:
            if c == n["name"].lower().strip():
                fValue = float(n[field])
                vList.append(fValue)
            else:
                pass
    # find and print the median value, nicely formatted
    medValue = stat.median(vList)
    print("The median {field} value for {currencylist} is:", medValue)
    
'''WORKS BUT OUTPUT NEEDS PRETTYING'''    
def minimum(datalist, currencylist, field):
    # create empty lists for data to be put into
    cList = []
    vList = []
    for i in currencylist:
        currency = i.lower().strip()
        cList.append(currency)
    # Iterate through datalist, lowercase and strip spaces, then check if each
    # the value for the given field matches each value from the cList. If yes,
    # add to vList.  If no, pass.
    for n in datalist:
        for c in cList:
            if c == n["name"].lower().strip():
                fValue = float(n[field])
                vList.append(fValue)
            else:
                pass
    # find and print minimum value, nicely formatted
    minValue = min(vList)
    print("The minimum {field} value for {currencylist} is:", minValue)
  
'''WORKS BUT OUTPUT NEEDS PRETTYING'''
def maximum(datalist, currencylist, field):
    # create empty lists for data to be put into
    cList = []
    vList = []
    for i in currencylist:
        currency = i.lower().strip()
        cList.append(currency)
    # Iterate through datalist, lowercase and strip spaces, then check if each
    # the value for the given field matches each value from the cList. If yes,
    # add to vList.  If no, pass.
    for n in datalist:
        for c in cList:
            if c == n["name"].lower().strip():
                fValue = float(n[field])
                vList.append(fValue)
            else:
                pass
    # find and print the maximum value, nicely formatted
    maxValue = max(vList)
    print("The maximum {field} value for {currencylist} is:", maxValue)
    

'''WORKS'''  
def above(datalist, field, threshold): # threshold is INCLUSIVE as of now
    print("The currencies with", field, "values above", threshold,
                      "are: ")
    # convert threshold input from string to float
    tVal = float(threshold)
    # iterate through the datalist, checking for None values. This avoids the
    # TypeError.  If item is not Nonetype, convert to float, then compare to
    # threshold. If greater than threshold, print the currency name and its
    # value for the chosen field.
    for i in datalist:
        if i[field] == None:
            pass
        else:
            cField = i[field]
            compField = float(cField)
            if compField >= tVal:
                print(i["name"] + ":", i[field])
   
'''WORKS'''
def below(datalist, field, threshold): #threshold is INCLUSIVE
    print("The currencies with", field, "value below", threshold, "are: ")
    # convert threshold input from string to float
    tVal = float(threshold)
    # iterate through the datalist, checking for None values. This avoids the
    # TypeError.  If item is not Nonetype, convert to float, then compare to
    # threshold. If less than threshold, print the currency name and its
    # value for the chosen field.
    for i in datalist:
        if i[field] == None:
            pass
        else:
            cField = i[field]
            compField = float(cField)
            if compField <= tVal:
                print(i["name"] + ":", i[field])

'''WORKS'''    
def between(datalist, field, vRange): 
    #rValues represents the range, will be a 2 item list or a tuple
    print("The currencies with", field, "values in the range", vRange, "are: ")
    # Split the user inputted range into two discrete strings
    splitRange = vRange.split("-")
    # Create empty list to put range values into
    rangeList = []
    # Convert range values to floats and add to rangeList
    for i in splitRange:
        rangeList.append(float(i))
    # Assign high and low end variables
    lowEnd = rangeList[0]
    highEnd = rangeList[1]
    # iterate through the datalist, checking for None values. This avoids the
    # TypeError.  If item is not Nonetype, convert to float, then compare to
    # range values. If within the chosen range, print the currency name and its
    # value for the chosen field.
    for i in datalist:
        if i[field] == None:
            pass
        else:
            cField = i[field]
            compField = float(cField)
            if lowEnd <= compField <= highEnd:
                print(i["name"] + ":", i[field])
    

'''function calls below are commented out, but feel free to use them to test'''    
#summary(cmcData, ["Aeternity", "0x"])
#average(cmcData, ["bitcoin", "qtum"], "price_usd")
#med(cmcData, ["bitcoin", "qtum", "aeternity", "0x"], "price_usd")
#minimum(cmcData, ["bitcoin", "qtum", "aeternity", "0x"], "price_usd") 
#maximum(cmcData, ["bitcoin", "qtum", "aeternity", "0x"], "price_usd")   
#above(cmcData, "price_usd", "1000")
#below(cmcData, "price_usd", "0.01") #THERE ARE SO MANY OF THESE
#between(cmcData, "price_usd", "10-20")
